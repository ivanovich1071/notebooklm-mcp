/**
 * Unit Tests for AutoDiscovery Class
 *
 * Tests cover:
 * 1. parseResponse: Valid JSON, markdown code blocks, missing fields, invalid JSON
 * 2. validateMetadata: Name validation (kebab-case), description length, tags count
 * 3. Integration: Successful discovery, retry on failure, max retries exceeded
 */

import { describe, test, expect, beforeEach, vi } from 'vitest';
import { AutoDiscovery, AutoGeneratedMetadata } from '../src/auto-discovery/auto-discovery.js';
import { SessionManager } from '../src/session/session-manager.js';
import { BrowserSession } from '../src/session/browser-session.js';

// Mock SessionManager and BrowserSession
vi.mock('../src/session/session-manager.js');
vi.mock('../src/session/browser-session.js');
vi.mock('../src/utils/logger.js', () => ({
  log: {
    info: vi.fn(),
    success: vi.fn(),
    error: vi.fn(),
    warning: vi.fn(),
    dim: vi.fn(),
  },
}));

describe('AutoDiscovery', () => {
  let autoDiscovery: AutoDiscovery;
  let mockSessionManager: SessionManager;
  let mockSession: BrowserSession;

  beforeEach(() => {
    // Reset all mocks before each test
    vi.clearAllMocks();

    // Create mock session with sendMessage method
    mockSession = {
      sendMessage: vi.fn(),
    } as any;

    // Create mock session manager
    mockSessionManager = {
      getOrCreateSession: vi.fn().mockResolvedValue(mockSession),
    } as any;

    // Create AutoDiscovery instance
    autoDiscovery = new AutoDiscovery(mockSessionManager);
  });

  // ============================================================================
  // parseResponse Tests
  // ============================================================================

  describe('parseResponse', () => {
    test('should parse valid JSON response', async () => {
      const validResponse = JSON.stringify({
        name: 'test-notebook',
        description: 'First sentence here. Second sentence here.',
        tags: ['tag1', 'tag2', 'tag3', 'tag4', 'tag5', 'tag6', 'tag7', 'tag8'],
      });

      mockSession.sendMessage = vi.fn().mockResolvedValue(validResponse);

      const result = await autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test');

      expect(result).toEqual({
        name: 'test-notebook',
        description: 'First sentence here. Second sentence here.',
        tags: ['tag1', 'tag2', 'tag3', 'tag4', 'tag5', 'tag6', 'tag7', 'tag8'],
      });
    });

    test('should parse JSON wrapped in markdown code blocks', async () => {
      const markdownResponse = `\`\`\`json
{
  "name": "markdown-test",
  "description": "Test description. Additional info.",
  "tags": ["a", "b", "c", "d", "e", "f", "g", "h"]
}
\`\`\``;

      mockSession.sendMessage = vi.fn().mockResolvedValue(markdownResponse);

      const result = await autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test');

      expect(result.name).toBe('markdown-test');
      expect(result.description).toBe('Test description. Additional info.');
      expect(result.tags).toHaveLength(8);
    });

    test('should parse JSON with extra whitespace', async () => {
      const whitespaceResponse = `

{
  "name": "whitespace-test",
  "description": "First. Second.",
  "tags": ["1", "2", "3", "4", "5", "6", "7", "8"]
}

`;

      mockSession.sendMessage = vi.fn().mockResolvedValue(whitespaceResponse);

      const result = await autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test');

      expect(result.name).toBe('whitespace-test');
    });

    test('should throw error for missing name field', async () => {
      const missingNameResponse = JSON.stringify({
        description: 'Description here. More info.',
        tags: ['tag1', 'tag2', 'tag3', 'tag4', 'tag5', 'tag6', 'tag7', 'tag8'],
      });

      mockSession.sendMessage = vi.fn().mockResolvedValue(missingNameResponse);

      await expect(
        autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test')
      ).rejects.toThrow('Missing required fields');
    });

    test('should throw error for missing description field', async () => {
      const missingDescResponse = JSON.stringify({
        name: 'test-name',
        tags: ['tag1', 'tag2', 'tag3', 'tag4', 'tag5', 'tag6', 'tag7', 'tag8'],
      });

      mockSession.sendMessage = vi.fn().mockResolvedValue(missingDescResponse);

      await expect(
        autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test')
      ).rejects.toThrow('Missing required fields');
    });

    test('should throw error for missing tags field', async () => {
      const missingTagsResponse = JSON.stringify({
        name: 'test-name',
        description: 'Description here. More info.',
      });

      mockSession.sendMessage = vi.fn().mockResolvedValue(missingTagsResponse);

      await expect(
        autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test')
      ).rejects.toThrow('Missing required fields');
    });

    test('should throw error for invalid JSON syntax', async () => {
      const invalidJsonResponse = '{ name: "invalid", description: "broken" }'; // Not valid JSON (missing quotes)

      mockSession.sendMessage = vi.fn().mockResolvedValue(invalidJsonResponse);

      await expect(
        autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test')
      ).rejects.toThrow('Invalid JSON response');
    });

    test('should throw error for completely invalid response', async () => {
      const invalidResponse = 'This is not JSON at all!';

      mockSession.sendMessage = vi.fn().mockResolvedValue(invalidResponse);

      await expect(
        autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test')
      ).rejects.toThrow('Invalid JSON response');
    });
  });

  // ============================================================================
  // validateMetadata Tests
  // ============================================================================

  describe('validateMetadata', () => {
    // Name validation tests
    describe('name validation', () => {
      test('should accept valid kebab-case name with 1 word', async () => {
        const response = JSON.stringify({
          name: 'notebook',
          description: 'Valid description. Second sentence.',
          tags: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'],
        });

        mockSession.sendMessage = vi.fn().mockResolvedValue(response);

        const result = await autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test');
        expect(result.name).toBe('notebook');
      });

      test('should accept valid kebab-case name with 2 words', async () => {
        const response = JSON.stringify({
          name: 'test-notebook',
          description: 'Valid description. Second sentence.',
          tags: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'],
        });

        mockSession.sendMessage = vi.fn().mockResolvedValue(response);

        const result = await autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test');
        expect(result.name).toBe('test-notebook');
      });

      test('should accept valid kebab-case name with 3 words (max)', async () => {
        const response = JSON.stringify({
          name: 'my-test-notebook',
          description: 'Valid description. Second sentence.',
          tags: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'],
        });

        mockSession.sendMessage = vi.fn().mockResolvedValue(response);

        const result = await autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test');
        expect(result.name).toBe('my-test-notebook');
      });

      test('should accept name with numbers', async () => {
        const response = JSON.stringify({
          name: 'notebook-v2',
          description: 'Valid description. Second sentence.',
          tags: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'],
        });

        mockSession.sendMessage = vi.fn().mockResolvedValue(response);

        const result = await autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test');
        expect(result.name).toBe('notebook-v2');
      });

      test('should reject name with spaces', async () => {
        const response = JSON.stringify({
          name: 'test notebook',
          description: 'Valid description. Second sentence.',
          tags: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'],
        });

        mockSession.sendMessage = vi.fn().mockResolvedValue(response);

        await expect(
          autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test')
        ).rejects.toThrow('Invalid name format');
      });

      test('should reject name with uppercase letters', async () => {
        const response = JSON.stringify({
          name: 'TestNotebook',
          description: 'Valid description. Second sentence.',
          tags: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'],
        });

        mockSession.sendMessage = vi.fn().mockResolvedValue(response);

        await expect(
          autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test')
        ).rejects.toThrow('Invalid name format');
      });

      test('should reject name with too many words (4 words)', async () => {
        const response = JSON.stringify({
          name: 'my-very-long-notebook',
          description: 'Valid description. Second sentence.',
          tags: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'],
        });

        mockSession.sendMessage = vi.fn().mockResolvedValue(response);

        await expect(
          autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test')
        ).rejects.toThrow('Invalid name format');
      });

      test('should reject name with underscores instead of hyphens', async () => {
        const response = JSON.stringify({
          name: 'test_notebook',
          description: 'Valid description. Second sentence.',
          tags: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'],
        });

        mockSession.sendMessage = vi.fn().mockResolvedValue(response);

        await expect(
          autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test')
        ).rejects.toThrow('Invalid name format');
      });

      test('should reject name with special characters', async () => {
        const response = JSON.stringify({
          name: 'test@notebook',
          description: 'Valid description. Second sentence.',
          tags: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'],
        });

        mockSession.sendMessage = vi.fn().mockResolvedValue(response);

        await expect(
          autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test')
        ).rejects.toThrow('Invalid name format');
      });
    });

    // Description validation tests
    describe('description validation', () => {
      test('should accept description with exactly 150 characters', async () => {
        const description = 'A'.repeat(75) + '. ' + 'B'.repeat(72) + '.'; // Exactly 150 chars

        const response = JSON.stringify({
          name: 'test-notebook',
          description: description,
          tags: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'],
        });

        mockSession.sendMessage = vi.fn().mockResolvedValue(response);

        const result = await autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test');
        expect(result.description).toHaveLength(150);
      });

      test('should accept description under 150 characters', async () => {
        const response = JSON.stringify({
          name: 'test-notebook',
          description: 'Short description. Very brief.',
          tags: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'],
        });

        mockSession.sendMessage = vi.fn().mockResolvedValue(response);

        const result = await autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test');
        expect(result.description.length).toBeLessThanOrEqual(150);
      });

      test('should reject description over 150 characters', async () => {
        const longDescription = 'A'.repeat(151); // 151 chars

        const response = JSON.stringify({
          name: 'test-notebook',
          description: longDescription,
          tags: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'],
        });

        mockSession.sendMessage = vi.fn().mockResolvedValue(response);

        await expect(
          autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test')
        ).rejects.toThrow('Description too long');
      });
    });

    // Tags validation tests
    describe('tags validation', () => {
      test('should accept exactly 8 tags (minimum)', async () => {
        const response = JSON.stringify({
          name: 'test-notebook',
          description: 'Valid description. Second sentence.',
          tags: ['tag1', 'tag2', 'tag3', 'tag4', 'tag5', 'tag6', 'tag7', 'tag8'],
        });

        mockSession.sendMessage = vi.fn().mockResolvedValue(response);

        const result = await autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test');
        expect(result.tags).toHaveLength(8);
      });

      test('should accept 9 tags', async () => {
        const response = JSON.stringify({
          name: 'test-notebook',
          description: 'Valid description. Second sentence.',
          tags: ['tag1', 'tag2', 'tag3', 'tag4', 'tag5', 'tag6', 'tag7', 'tag8', 'tag9'],
        });

        mockSession.sendMessage = vi.fn().mockResolvedValue(response);

        const result = await autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test');
        expect(result.tags).toHaveLength(9);
      });

      test('should accept exactly 10 tags (maximum)', async () => {
        const response = JSON.stringify({
          name: 'test-notebook',
          description: 'Valid description. Second sentence.',
          tags: ['tag1', 'tag2', 'tag3', 'tag4', 'tag5', 'tag6', 'tag7', 'tag8', 'tag9', 'tag10'],
        });

        mockSession.sendMessage = vi.fn().mockResolvedValue(response);

        const result = await autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test');
        expect(result.tags).toHaveLength(10);
      });

      test('should reject too few tags (7 tags)', async () => {
        const response = JSON.stringify({
          name: 'test-notebook',
          description: 'Valid description. Second sentence.',
          tags: ['tag1', 'tag2', 'tag3', 'tag4', 'tag5', 'tag6', 'tag7'],
        });

        mockSession.sendMessage = vi.fn().mockResolvedValue(response);

        await expect(
          autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test')
        ).rejects.toThrow('Invalid tags count');
      });

      test('should reject too many tags (11 tags)', async () => {
        const response = JSON.stringify({
          name: 'test-notebook',
          description: 'Valid description. Second sentence.',
          tags: ['tag1', 'tag2', 'tag3', 'tag4', 'tag5', 'tag6', 'tag7', 'tag8', 'tag9', 'tag10', 'tag11'],
        });

        mockSession.sendMessage = vi.fn().mockResolvedValue(response);

        await expect(
          autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test')
        ).rejects.toThrow('Invalid tags count');
      });

      test('should reject empty tag string', async () => {
        const response = JSON.stringify({
          name: 'test-notebook',
          description: 'Valid description. Second sentence.',
          tags: ['tag1', 'tag2', '', 'tag4', 'tag5', 'tag6', 'tag7', 'tag8'],
        });

        mockSession.sendMessage = vi.fn().mockResolvedValue(response);

        await expect(
          autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test')
        ).rejects.toThrow('Invalid tag');
      });

      test('should reject whitespace-only tag', async () => {
        const response = JSON.stringify({
          name: 'test-notebook',
          description: 'Valid description. Second sentence.',
          tags: ['tag1', 'tag2', '   ', 'tag4', 'tag5', 'tag6', 'tag7', 'tag8'],
        });

        mockSession.sendMessage = vi.fn().mockResolvedValue(response);

        await expect(
          autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test')
        ).rejects.toThrow('Invalid tag');
      });

      test('should reject non-string tag', async () => {
        const response = JSON.stringify({
          name: 'test-notebook',
          description: 'Valid description. Second sentence.',
          tags: ['tag1', 'tag2', null, 'tag4', 'tag5', 'tag6', 'tag7', 'tag8'],
        });

        mockSession.sendMessage = vi.fn().mockResolvedValue(response);

        await expect(
          autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test')
        ).rejects.toThrow('Invalid tag');
      });
    });
  });

  // ============================================================================
  // Integration Tests
  // ============================================================================

  describe('Integration: discoverMetadata', () => {
    test('should successfully discover metadata on first attempt', async () => {
      const validResponse = JSON.stringify({
        name: 'react-hooks',
        description: 'React Hooks guide. Covers useState and useEffect.',
        tags: ['react', 'hooks', 'useState', 'useEffect', 'frontend', 'javascript', 'web', 'development'],
      });

      mockSession.sendMessage = vi.fn().mockResolvedValue(validResponse);

      const result = await autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test');

      expect(result).toEqual({
        name: 'react-hooks',
        description: 'React Hooks guide. Covers useState and useEffect.',
        tags: ['react', 'hooks', 'useState', 'useEffect', 'frontend', 'javascript', 'web', 'development'],
      });

      expect(mockSessionManager.getOrCreateSession).toHaveBeenCalledTimes(1);
      expect(mockSession.sendMessage).toHaveBeenCalledTimes(1);
    });

    test('should retry on failure and succeed on second attempt', async () => {
      const validResponse = JSON.stringify({
        name: 'retry-test',
        description: 'Test retry logic. Should succeed.',
        tags: ['retry', 'test', 'success', 'failure', 'recovery', 'resilience', 'error', 'handling'],
      });

      // First call fails, second succeeds
      mockSession.sendMessage = vi
        .fn()
        .mockRejectedValueOnce(new Error('Network error'))
        .mockResolvedValueOnce(validResponse);

      // Mock delay to speed up test
      vi.spyOn(autoDiscovery as any, 'delay').mockResolvedValue(undefined);

      const result = await autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test');

      expect(result.name).toBe('retry-test');
      expect(mockSessionManager.getOrCreateSession).toHaveBeenCalledTimes(2);
      expect(mockSession.sendMessage).toHaveBeenCalledTimes(2);
    });

    test('should retry on invalid JSON and succeed on second attempt', async () => {
      const validResponse = JSON.stringify({
        name: 'json-retry',
        description: 'JSON parsing retry test. Should work eventually.',
        tags: ['json', 'parsing', 'retry', 'validation', 'error', 'recovery', 'test', 'success'],
      });

      // First call returns invalid JSON, second returns valid
      mockSession.sendMessage = vi
        .fn()
        .mockResolvedValueOnce('Invalid JSON response')
        .mockResolvedValueOnce(validResponse);

      // Mock delay to speed up test
      vi.spyOn(autoDiscovery as any, 'delay').mockResolvedValue(undefined);

      const result = await autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test');

      expect(result.name).toBe('json-retry');
      expect(mockSession.sendMessage).toHaveBeenCalledTimes(2);
    });

    test('should retry on validation failure and succeed on second attempt', async () => {
      const invalidResponse = JSON.stringify({
        name: 'INVALID NAME', // Invalid: uppercase and spaces
        description: 'Test description. Second sentence.',
        tags: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'],
      });

      const validResponse = JSON.stringify({
        name: 'valid-name',
        description: 'Test description. Second sentence.',
        tags: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'],
      });

      // First call returns invalid metadata, second returns valid
      mockSession.sendMessage = vi
        .fn()
        .mockResolvedValueOnce(invalidResponse)
        .mockResolvedValueOnce(validResponse);

      // Mock delay to speed up test
      vi.spyOn(autoDiscovery as any, 'delay').mockResolvedValue(undefined);

      const result = await autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test');

      expect(result.name).toBe('valid-name');
      expect(mockSession.sendMessage).toHaveBeenCalledTimes(2);
    });

    test('should fail after exceeding max retries (default: 2)', async () => {
      // All attempts fail
      mockSession.sendMessage = vi.fn().mockRejectedValue(new Error('Persistent error'));

      // Mock delay to speed up test
      vi.spyOn(autoDiscovery as any, 'delay').mockResolvedValue(undefined);

      await expect(
        autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test')
      ).rejects.toThrow('Auto-discovery failed');

      // Should have tried 3 times total (initial + 2 retries)
      expect(mockSessionManager.getOrCreateSession).toHaveBeenCalledTimes(3);
      expect(mockSession.sendMessage).toHaveBeenCalledTimes(3);
    });

    test('should respect custom maxRetries parameter', async () => {
      // All attempts fail
      mockSession.sendMessage = vi.fn().mockRejectedValue(new Error('Persistent error'));

      // Mock delay to speed up test
      vi.spyOn(autoDiscovery as any, 'delay').mockResolvedValue(undefined);

      await expect(
        autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test', 1)
      ).rejects.toThrow('Auto-discovery failed');

      // Should have tried 2 times total (initial + 1 retry)
      expect(mockSessionManager.getOrCreateSession).toHaveBeenCalledTimes(2);
      expect(mockSession.sendMessage).toHaveBeenCalledTimes(2);
    });

    test('should pass correct notebook URL to session manager', async () => {
      const validResponse = JSON.stringify({
        name: 'url-test',
        description: 'Test URL passing. Should work correctly.',
        tags: ['url', 'test', 'session', 'manager', 'notebook', 'passing', 'validation', 'success'],
      });

      mockSession.sendMessage = vi.fn().mockResolvedValue(validResponse);

      const notebookUrl = 'https://notebooklm.google.com/notebook/abc123';
      await autoDiscovery.discoverMetadata(notebookUrl);

      expect(mockSessionManager.getOrCreateSession).toHaveBeenCalledWith(
        undefined,
        notebookUrl
      );
    });

    test('should send correct discovery prompt to NotebookLM', async () => {
      const validResponse = JSON.stringify({
        name: 'prompt-test',
        description: 'Test prompt generation. Should be correct.',
        tags: ['prompt', 'generation', 'test', 'discovery', 'validation', 'format', 'rules', 'json'],
      });

      mockSession.sendMessage = vi.fn().mockResolvedValue(validResponse);

      await autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test');

      const promptCall = mockSession.sendMessage.mock.calls[0][0];

      // Verify prompt contains key instructions
      expect(promptCall).toContain('Analyze your complete content');
      expect(promptCall).toContain('ONLY in this JSON format');
      expect(promptCall).toContain('kebab-case');
      expect(promptCall).toContain('between 8 and 10 keywords');
      expect(promptCall).toContain('under 150 characters');
      expect(promptCall).toContain('OUTPUT ONLY VALID JSON');
    });

    test('should handle markdown code block with language identifier', async () => {
      const markdownResponse = `\`\`\`json
{
  "name": "markdown-lang-test",
  "description": "Markdown with language identifier. Should parse correctly.",
  "tags": ["markdown", "json", "parsing", "language", "identifier", "test", "validation", "success"]
}
\`\`\``;

      mockSession.sendMessage = vi.fn().mockResolvedValue(markdownResponse);

      const result = await autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test');

      expect(result.name).toBe('markdown-lang-test');
    });

    test('should handle markdown code block without language identifier', async () => {
      const markdownResponse = `\`\`\`
{
  "name": "markdown-no-lang",
  "description": "Markdown without language identifier. Should parse correctly.",
  "tags": ["markdown", "parsing", "no-lang", "test", "validation", "success", "format", "json"]
}
\`\`\``;

      mockSession.sendMessage = vi.fn().mockResolvedValue(markdownResponse);

      const result = await autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test');

      expect(result.name).toBe('markdown-no-lang');
    });
  });

  // ============================================================================
  // Edge Cases and Error Handling
  // ============================================================================

  describe('Edge Cases', () => {
    test('should handle response with extra fields', async () => {
      const responseWithExtra = JSON.stringify({
        name: 'extra-fields',
        description: 'Has extra fields. Should ignore them.',
        tags: ['extra', 'fields', 'test', 'validation', 'ignore', 'success', 'parsing', 'json'],
        extraField: 'This should be ignored',
        anotherField: 123,
      });

      mockSession.sendMessage = vi.fn().mockResolvedValue(responseWithExtra);

      const result = await autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test');

      expect(result).toEqual({
        name: 'extra-fields',
        description: 'Has extra fields. Should ignore them.',
        tags: ['extra', 'fields', 'test', 'validation', 'ignore', 'success', 'parsing', 'json'],
      });
    });

    test('should handle name with consecutive hyphens', async () => {
      const response = JSON.stringify({
        name: 'test--notebook', // Consecutive hyphens - should be invalid
        description: 'Test consecutive hyphens. Should fail.',
        tags: ['test', 'hyphens', 'consecutive', 'validation', 'failure', 'error', 'invalid', 'format'],
      });

      mockSession.sendMessage = vi.fn().mockResolvedValue(response);

      await expect(
        autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test')
      ).rejects.toThrow('Invalid name format');
    });

    test('should handle name starting with hyphen', async () => {
      const response = JSON.stringify({
        name: '-test-notebook',
        description: 'Name starts with hyphen. Should fail.',
        tags: ['test', 'hyphen', 'start', 'validation', 'failure', 'error', 'invalid', 'format'],
      });

      mockSession.sendMessage = vi.fn().mockResolvedValue(response);

      await expect(
        autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test')
      ).rejects.toThrow('Invalid name format');
    });

    test('should handle name ending with hyphen', async () => {
      const response = JSON.stringify({
        name: 'test-notebook-',
        description: 'Name ends with hyphen. Should fail.',
        tags: ['test', 'hyphen', 'end', 'validation', 'failure', 'error', 'invalid', 'format'],
      });

      mockSession.sendMessage = vi.fn().mockResolvedValue(response);

      await expect(
        autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test')
      ).rejects.toThrow('Invalid name format');
    });

    test('should handle empty name', async () => {
      const response = JSON.stringify({
        name: '',
        description: 'Empty name. Should fail.',
        tags: ['test', 'empty', 'name', 'validation', 'failure', 'error', 'invalid', 'format'],
      });

      mockSession.sendMessage = vi.fn().mockResolvedValue(response);

      await expect(
        autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test')
      ).rejects.toThrow('Invalid name format');
    });

    test('should handle empty description', async () => {
      const response = JSON.stringify({
        name: 'test-notebook',
        description: '',
        tags: ['test', 'empty', 'description', 'validation', 'success', 'valid', 'format', 'short'],
      });

      mockSession.sendMessage = vi.fn().mockResolvedValue(response);

      // Empty description is valid as long as it's under 150 chars
      const result = await autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test');
      expect(result.description).toBe('');
    });

    test('should handle tags as array of numbers (should fail)', async () => {
      const response = JSON.stringify({
        name: 'test-notebook',
        description: 'Tags are numbers. Should fail.',
        tags: [1, 2, 3, 4, 5, 6, 7, 8],
      });

      mockSession.sendMessage = vi.fn().mockResolvedValue(response);

      await expect(
        autoDiscovery.discoverMetadata('https://notebooklm.google.com/notebook/test')
      ).rejects.toThrow('Invalid tag');
    });
  });
});
